# -*- coding: utf-8 -*-
"""cubic_spline.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KjqqjEkfBftYmIrLEyv-ONg2Pb_UZmo-
"""

# This module contains the definition of function "cubic_spline"
# This function takes T,k,skip,T1,T2 as variable
# T and k is the data points of x-axis and y-axis respectively
# skip is a value such that if user want to perform task based on a subset of the given dataset, put skip=0 or else put skip>=1 to perform on entire given dataset
# T1 and T2 are the values of T within its given range, for which the user wants to find the interpolation value
# We took a diagonal matrix 'g' whose inverse is multiplied with matrix 'B' that gives the matrix 'm'
# Mi : S''i(xi) ; h is the difference between consecutive value of T data points(T2-T1)
# Mi + 4M(i+1) + M(i+2) = 6/h^2((y(i) - 2y(i+1) + y(i+2)) is the equation obtained by doing some algebra based on which the method is done
# the values of 'm' is used to find the coefficients of the cubic spline
# d array gives the coefficients of degree 3 terms
# c array gives the coefficients of degree 2 terms
# b array gives the coefficients of degree 1 terms
# a array gives the constant terms
#the coefficient matrices are printed and also shown in output file
#plot is done based on the cubic spline equations those were obtained as S0,S1,S2,..etc
###########################################X##################################################

import numpy as np
import matplotlib.pyplot as plt
def cubic_spline(T,k,skip,T1,T2):  #if user want to perform task based on a subset of the given dataset, put skip=0 or else put skip>=1 to perform on entire given dataset
 if skip == 0:   
  sbst = 3
  X = T
  y = k
  p=len(X)
  q=len(y)
  p=q; p<q
  if len(X)%2<=0 and len(y)%2<=0:
   k = [y[0]]
   c = 0
   for c in range(0,q-2,sbst):
    k.append(y[c+1])
    T = [X[0]]
    c = 0
   for c in range(0,p-2,sbst):
    T.append(X[c+1])
  elif len(X)%2!=0 and len(y)%2!=0:
   k = []
   c = 0
   for c in range(0,q-2,sbst):
    k.append(y[c])
    T = []
    c = 0
   for c in range(0,p-2,sbst):
    T.append(X[c])
  k.append(y[q-1])
  T.append(X[p-1])

 print('The given dataset is: ')
 Data = []
 for each_xdata,each_ydata in zip(T,k):
  temp = []
  temp.append(each_xdata)
  temp.append(each_ydata)
  Data.append(temp)                  # Data is a array that gives the (x,y) datasets
 print(Data)

 K = np.array(k)
 Range = len(T)-1

 S = []                           #this array is only taken to print splines as S0,S1,S2,...etc
 for i in range(Range):
  Q = i
  S.insert(i,Q)
 
   
# NOW TO FIND INTERPOLATION VALUE
 N = []
 for i in range(Range):                      #N is a array that contains the range of T values(Ex: T1-T2,T2-T3,...) for which different splines are to be obtained
  Q = range(int(T[i]), int(T[i+1]))
  N.insert(i,Q)


 

 R = len(k) - 2                                # Mi + 4M(i+1) + M(i+2) = 6/h^2((y(i) - 2y(i+1) + y(i+2)) ---- Eq-1
 C = len(k) - 2                                # Mi : S''i(xi)
 g = np.zeros([R,C])                           # h is the difference between consecutive value of T data points(T(n+1)-T(n))

 for i in range(R-2):
  g[i][i] = 4
  g[i][i+1]= 1
  g[i][i+2]= 0
  g[i+1][i]= 1
 g[C-1,R-1] = 4
 g[C-2,R-1] = 1    
 g[C-1,R-2] = 1
 g[C-2,R-2] = 4   
#print(g) 
 invg = np.linalg.inv(g)                      # g is the diagonal array from the coefficients of LHS of the Eq-1 above
#print(invg)


 B = np.zeros([Range-1,1])
 for i in range(Range-1):                     # B is array that defines the RHS of the Eq-1
  h = T[i+1]-T[i]
  B[i][0] = 6*k[i]/h**2 -12*k[i+1]/h**2 + 6*k[i+2]/h**2   

#print(B)

 M = np.dot(invg,B)             # m = Bg^(-1)
 m = np.insert(M,0,0)
 m = np.insert(m,Range,0)

#print(m)

 d = []
 for i in range(0,Range):
  h = T[i+1]-T[i]
  dd = (m[i+1] - m[i])/(6*h)                      # d array gives the coefficients of degree 3 terms
  d.insert(i,dd)
 print('Coefficients of term with degree 3;')
 print(d)

 c = []
 for i in range(0,Range+1):
  cc = (m[i])/2                                   # c array gives the coefficients of degree 2 terms
  c.insert(i,cc)
 print('Coefficients of term with degree 2;')
 print(c)

 b = []
 for i in range(0,Range):
  h = T[i+1]-T[i]
  bb = ((K[i+1] - K[i])/h) - h*(m[i+1] + 2*m[i])/6
  b.insert(i,bb)                                           # b array gives the coefficients of degree 1 terms
 print('Coefficients of term with degree 1;')
 print(b)

 a = []
 for i in range(Range):
  q = K[i]
  a.insert(i,q)
 print('Constant terms;')                                     # a array gives the constant terms
 print(a)

 CS = open("cubic_splines_subset.txt", "w+")     #CS- cubicspline
 data_set = str(Data)                     #these are used to get output file as txt file which contains the dataset, the coefficient of obtained splines and the sline equations.
 cf_d = str(d)
 cf_c = str(c)
 cf_b = str(b)
 cf_a = str(a)
 print('The dataset is shown below :-',file = CS)
 CS.write(data_set + '\n')
 print('',file = CS)     #to put a space in between lines
 print('The coefficients of degree 3 are shown below :-',file = CS)
 CS.write(cf_d + '\n')    
 print('',file = CS)     #to put a space in between lines
 print('The coefficients of degree 2 are shown below :-',file = CS)
 CS.write(cf_c + '\n')
 print('',file = CS)      #to put a space in between lines
 print('The coefficients of degree 1 are shown below :-',file = CS)
 CS.write(cf_b + '\n')
 print('',file = CS)      #to put a space in between lines
 print('The constant terms are shown below :-',file = CS)
 CS.write(cf_a + '\n')
 print('',file = CS)

# TO PRINT DIFFERENT SPLINES WITH RESPECTIVE COEFFICIENTS
 print('The cubic splines with respective equations are below:',file = CS)
 print('The cubic splines with respective equations are below:')
 for i in range(Range):
  print('S -',S[i],'(',int(T[i]), '<= T <=',int(T[i+1]),' ) = ', a[i], ' + ', b[i], '(T -',int(T[i]),') + ', c[i], '(T -',int(T[i]),')^2  + ', d[i], '(T -',int(T[i]),')^3',file=CS)
 CS.close()


 def test_range_intrpltval(p):           # this function checks the value of T(for which user wants to find interpolation value) lies in which spline and use respective spline equation to find the interpolation value
  for j in range(Range): 
   if min(N[j]) <= p <= max(N[j]) and round(p,5)==p:
    IV = a[j] + b[j]*(p - min(N[j])) + c[j]*(p - min(N[j]))**2 + d[j]*(p - min(N[j]))**3  #S = a + b(T-x) + c(T-x)^2 + d(T-x)^3 that is the general equation for cubic spline
    print('K(', p,') = ', IV)
 print('Interpolation values are below:')   
 test_range_intrpltval(T1)   
 test_range_intrpltval(T2)

 plt.figure(figsize=(10,5))            #plot is enlarged

 for j in range(Range):
  iii = np.linspace(min(N[j]),max(N[j]),num=100)
  new1 = a[j] + b[j]*(iii - min(N[j])) + c[j]*(iii - min(N[j]))**2 + d[j]*(iii - min(N[j]))**3     #S = a + b(T-x) + c(T-x)^2 + d(T-x)^3 that is the general equation for cubic spline
  plt.plot(iii, new1, 'b')
 plt.plot(T, k, 'o', color='red');
 plt.xlabel('T value')
 plt.ylabel( 'K value')
 plt.title('Plotting of cubic spline')
 plt.grid('on') 
 plt.show()